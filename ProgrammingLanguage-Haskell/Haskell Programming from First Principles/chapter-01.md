# All You Need is Lambda

> 即使是最伟大的数学家，那些我们会放入我们神话中的伟大数学家，也必须做大量的底层工作，以便最后得到解决方案。
>
> ------ Daniel Tammett

## 1.1 你所需要的是 Lambda

本章对 λ 演算作了非常简要的介绍，它是 Alonzo Church 在 1930 年代设计的一种计算模型。微积分是一种计算或推理方法，而 λ 演算则是将方法形式化的一个过程。像图灵机一样，λ 演算定义了有效可计算性的概念，从而确定哪些问题或问题类别可以被解决。

你可能想知道 Haskell 在哪里？你可能在考虑跳过这一章节。当我们建立一个项目时，你可能会觉得很想跳过前面有趣的内容。

不行！

我们在这里从第一原则开始，以便当我们开始建立项目时，你知道你在做什么。你不能从阁楼往下开始建造房子，你应该从地基开始。λ 演算会是你的根基，因为 Haskell 就是一个 λ 演算。

## 1.2 什么是函数式编程？

函数式编程是一种计算机编程范式，依赖于以数学函数为模型的函数。函数式编程的本质是：程序是表达式的组合。表达式包括具体的数值、变量，也包括函数。函数有一个更具体的定义：它们是应用于参数或输入的表达式，一旦调用，就可以被折算或执行。在 Haskell 中，以及在更广泛的函数式编程中，函数是一等公民：它们可以被作为值使用，或作为参数、或输入，传递给更多的函数。随着本章节的深入，我们将更仔细地定义这些术语。

函数式编程语言都是基于 λ 演算的。在这类语言中，有些语言包含了一些不能被翻译成 λ 表达式的特性。Haskell 是一门纯粹的函数式语言，因为它没有那样做。我们将在本书后面更多地讨论有关纯粹性这个概念，但这并不是作为判定其它语言道德价值的标准。

在函数式编程中，纯粹性一词更恰当地的说法是指引用透明性。引用透明性意味着对于同一个函数，给定相同的值进行执行，在纯函数式编程中总是会返回相同的结果，就像它们在数学中一样。

Haskell 的纯函数式基础也使得它具有高度的抽象性和可组合性。抽象使你能够通过将常见的、重复的结构分解成更多的、可以重复使用的通用代码来编写更短、更简洁的程序。Haskell 程序是由单独的、独立的函数构建的，有点像乐高：这些函数是可被组装和重新组装的砖块。

这些特点也使得 Haskell 的语法相当简洁，很快你就会看到。

## 1.3 什么是函数？

如果我们不使用“Lambda”这个词，你很可能已经知道什么是函数了。一个函数是一组可能的输入和一组可能的输出之间的关系。函数本身定义并代表了这种关系。当你将一个函数（如加法）应用于两个输入时，它将这两个输入映射到一个输出 —— 这些数字之和。

例如，让我们设想一个名为 $f$ 的函数，它定义了以下关系，其中第一个值是输入，第二个是输出：

$$f(1) = A$$

$$f(2) = B$$

$$f(3) = C$$

输入集为 $\{1, 2, 3\}$，输出集为 $\{A, B, C\}$。关于如何定义这些关系的一个关键点是：我们假设函数在输入 $1$ 的情况下总是会返回值 $A$ —— 没有例外。

与此相反，下面的内容不是一个有效的函数：

$$f(1) = X$$

$$f(1) = Y$$

$$f(2) = Z$$

这又回到了我们前面提到的引用透明性：给定相同的输入，输出应该是可预测的。

以下函数是否有效？

$$f(1) = A$$

$$f(2) = A$$

$$f(3) = A$$

是的，对一个以上的输入有相同的输出是有效的。例如，想象一下，你需要一个函数来测试一个正整数是否小于 10。你想让它在输入小于 10 的时候返回 True，在其他情况下返回 False。在这种情况下，几个不同的输入会导致输出为 True，更多的输入会得到一个 False 的结果，不同的输入可以导致相同的输出。

这里重要的是，输入和输出的关系是由函数定义的，而且当你知道输入和函数定义时，输出是可以预测的。

在上面的例子中，我们并没有展示输入和输出之间的关系。让我们看一个例子，它确实定义了这种关系，这个函数再次被命名为 $f$：

$$f(x) = x + 1$$

这个函数需要一个参数，我们将其命名为 $x$。在函数主体中描述了输入 $x$ 和输出之间的关系，它将在 $x$ 的任何数值上加 $1$，并返回该结果。当我们将这个函数应用于一个值，如 $1$，我们将该值替换给 $x$：

$$f(1) = 1 + 1$$

$f$ 应用于 $1$ 等于 $1 + 1$，这告诉我们如何将输入映射到输出，即 $1$ 加上 $1$ 变成 $2$：

$$f(1) = 2$$

以这种方式理解函数 —— 作为一组输入映射到一组输出 —— 对于理解函数式编程至关重要。

## 1.4 λ 公式的构造

λ 演算有三个基本组成部分，或称为 λ 公式：表达式、变量和抽象。表达式这个词指的是所有这些东西的超集：表达式可以是一个变量名、一个抽象概念或这些东西的组合。最简单的表达式是一个单一的变量，这里的变量没有任何意义或价值，它们只是潜在的函数输入的名称。

一个函数就是一个抽象，它是一个有头和主体的 λ 公式，并被应用于一个参数，参数是指一个输入值。

抽象由两部分组成：头部和主体。函数的头部是一个 𝜆，后面跟一个变量名。该函数的主体是另一个表达式。因此，一个简单的函数可能会是这样的：

$$λx . x$$

在头部命名的变量是参数，并在函数的主体中绑定该变量的所有实例。这意味着，当我们将这个函数应用于一个参数时，函数主体中的每一个 $x$ 都将具有该参数的值。我们将在下一节中演示这一点。

在上一节中，我们谈论的是名为 $f$ 的函数，但 λ 抽象 $λx . x$ 没有名字，它是一个匿名函数。一个具名函数可以被另一个函数通过名称进行调用，匿名函数则不行。

让我们来分解一下基本结构，将 $λx . x$ 分解成两部分：「 $λx .$ 」和 「 $x$ 」。

1. 「 $λx .$ 」是 λ 公式的头部范围，其中的 $x$ 是函数的单一参数，这将绑定到函数主体中任何具有相同名称的变量。
2. 「 $x$ 」是 λ 公式的主体，当应用 λ 时返回的表达式，在这里它是一个绑定变量。

符号点（ $.$ ）用于将 λ 的参数与函数体分开。

抽象的整体没有名字，但我们之所以称它为抽象，是因为它是从问题的具体实例中概括出来的，或者说是抽象出来的，它是通过引入名字来抽象的。这些名字代表了具体的值，但是通过使用命名的变量，我们允许将一般的函数应用于不同的值（或者，也许甚至是不同类型的值，我们将在后面看到）的可能性。当我们把抽象的东西应用于参数时，我们用值来代替名称，使之具象化。

### α 变换

通常，当人们用 λ 演算表达这个函数时，你会看到这样的东西：

$$λx . x$$

这里的变量 $x$ 除了在该单一表达式中的作用外，没有语义上的意义。正因为如此，λ 公式之间有一种等价的形式，叫做 α 等价变换。这也是一种表达方式：

$$λx . x$$

$$λd . d$$

$$λz . z$$

这也意味着同样的事情，它们都是同样的功能。

接下来让我们看看当我们把这个抽象概念应用于一个值时会发生什么。

## 1.5 β 还原

当我们将一个函数应用于一个参数时，我们将输入的表达式替换到抽象主体内的所有绑定变量的实例。你也消除了抽象的头部，因为它的唯一目的是绑定一个变量，这个过程被称为 β 还原。

让我们使用上面的函数：

$$λx . x$$

我们将用一个数字做我们的第一个 β 还原。将上面的函数应用于 $2$，用 $2$ 代替函数主体中的每个约束变量，并消除头部：

$$
\begin{align}
(λx . x)&2
\\
&2
\end{align}
$$

唯一的约束变量是单一的 $x$，因此将此函数应用于 $2$，返回 $2$。这个函数是恒等函数，它所做的只是接受一个参数 $x$，并返回同一个参数。

## 中英词组对照

|             中 | 英                         |
| -------------: | :------------------------- |
|            `β` | `beta`                     |
|            `α` | `alpha`                    |
|            `λ` | `lambda`                   |
|       `微积分` | `calculus`                 |
|    `还原/归约` | `reduction`                |
|         `变换` | `equivalence`              |
|       `λ 公式` | `lambda terms`             |
|       `λ 演算` | `lambda calculus`          |
|       `α 变换` | `alpha equivalence`        |
|       `β 还原` | `beta reduction`           |
|         `定义` | `formalizes`               |
|       `形式化` | `formalizing`              |
|      `纯/纯粹` | `pure`                     |
|       `纯粹性` | `purity`                   |
|    `折算/归纳` | `reduce`                   |
|     `底层工作` | `legwork`                  |
|         `恒等` | `identity`                 |
|     `一等公民` | `first-class`              |
| `有效可计算性` | `effective computability`  |
|   `引用透明性` | `referential transparency` |
