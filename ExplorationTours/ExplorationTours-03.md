# Programming Paradigms

## 编程范式

编程范式，是根据编程语言的特点进行分类的一种方式。

可划分为不同的角度，如关注对语言执行模型的影响、或是代码的组织方式、语法或句法的风格。

### 编程范式关系图

## 命令式编程

- 结构化编程
- 面向对象编程

## 声明式编程

- 响应式编程
  - 数据驱动
  - 事件驱动
- 函数式编程
  - 不变性
  - 副作用
  - 纯函数
- 函数式响应式编程
  - FRP - React
    - Redux
  - Event Stream - Angular
    - Rx
  - Transparently FRP
    - Mobx
    - Vue Reactivity
    - Solid Signal

## 组合与聚合

## 贫血模型与充血模型

## 视图交互与业务交互

## Daft

声明式编程、响应式编程、函数式编程、面向对象编程

声明式编程包括响应式编程与函数式编程

函数式编程可以和响应式编程结合

面向对象编程可以和响应式编程结合

函数式编程和面向对象编程是平行关系

---

## 响应式编程

响应式，即应对某种行为自动做出相应的反应。例如当值发生变化时做某某事、当事件被触发时要做些什么。

> 它是隶属于声明式编程（Declarative Programming，DP）旗下的一个子范式。

同时，这类行为是属于未知的，因此本质上需要基于异步回调的机制去处理各类问题。

结合人机交互的本质，在响应式编程中，又被划分为了两大分支：数据驱动与事件驱动。

所谓驱动主体，是由流程的发起方决定。

### 数据驱动

数据驱动，即流程的发起由数据的变化而产生。

数据驱动的核心要素就是状态，状态是「变化」的唯一凭证，旨在当时间前后的数据不等时，要做出的某种反应。

```ts
if (!Object.is(oldValue, newValue)) dispatchProcess()
```

### 事件驱动

事件驱动，即流程的发起由事件被触发而产生。

事件驱动不在乎你做了什么，只在乎你做了没有。

你一做我就知道你要搞事，我就开始全局范围内保守式地检查所有数据（脏检测），宁可错杀一千不可放过一个。

```ts
const nativeAddEventListener = window.addEventListener

window.addEventListener = (type, handler) => {
  nativeAddEventListener(type, (e) => {
    handler(e)
    dispatchProcess()
  })
}
```

---

## 物以类聚人以群分

分类要有边界。

举例：

我有一个主机和显示器，配了一个无线鼠标和一个无线键盘，共同组合成一台个人电脑。其中，主机可以任意放置在任意地方（假设线头够长），同理，显示器可以放置任意地方，假设你是千里眼。再者，无线键鼠也可以任意放置，只要在无线接收器的范围内，以及你的手够长。注意，这里的范围被无限扩大了，本身就带来了很多问题，因为不合理。

所以，首先我们得划定一个界限，将所有的东西先放置在一个房间内，即项目中。

当我的电脑再增加一个，依旧是这样的分法，没问题。

继续加，继续分，当加到 10 个的时候，依旧是键鼠放置一起，显示器放置一起，主机放在一起。

这时候问题就会出现了，你怎么知道哪套键鼠是属于哪套主机的呢？无线接收器在配对的时候你知道，配对完之后的信号发射，是肉眼不可见的。

所以，你在操作的时候，必须要时刻观察是哪台电脑动了，而且，还需要排除其它电脑带来的影响。

要解决这个问题，只有两个，一是熟能生巧，二是增加命名空间。

但是这只能缓解问题而不能解决问题，熟能生巧不利于新手介入，命名空间仍有尽头（指的是人脑所能承受的范围，一百个命名空间你要怎么起名，你要怎么记？）

第二个问题，就是可维护性、可移植性，你需要在众多分类中找出属于这台电脑的所有组成部分，才可将其移除（报废了），或是移入另一个房间（移植）。

这很考验维护人员的耐心，否则可能会遗留无用的产物，对房间增加负担，日益臃肿。

处于便利性（可移植性）而言，于是便研发出了笔记本电脑（不同的是，鼠标变为的触控板，当然意思差不多得了）
