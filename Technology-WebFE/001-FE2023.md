# FE 发展动向与趋势

## 框架发展

主流框架发展重要节点：

- 2020-09-18 Vue v3.0.0 发布
- 2019-02-06 React v16.8.0 发布
- 2016-09-15 Angular v2.0.0 发布

当 Vue v3.x 完整前端框架界的最后一块拼图时，意味着前端框架已趋于成熟，都拥有了「状态 + 逻辑」的复用能力，「状态管理」即将落入历史长河。

再者就是架构模式的不同，Angular 是基于事件驱动，Vue 基于响应式的数据驱动，而 React 则是基于不可变性的状态驱动。

那么这些框架剩下的工作就是千锤百炼，精益求精了，如：Vue v3.2 的 setup-sugar 以及 React v18 的并发延迟 Hooks。

现代框架「返祖」：

- Solid.js
- Svelte.js
- Vue v3.x Vapor - Non-VDom Compilation Strategy

去 VDom 化，追求极致的「声明式」开发体验，编译成纯原生的「命令式」源码。

因为 VDom 最强大的是抽象能力，使其拥有强大的跨平台能力。除此之外，框架本身一般还会对 VDom 进行增强，创造属于自己的 DSL （Template vs JSX），如 Vue 的 Block Tree 以及 React 的 Fiber Tree。

> Atwood 定律：Any application that can be written in JavaScript, will eventually be written in JavaScript.

当我们不需要跨平台的时候（或者跨平台本身就是个伪需求），那也就意味着我们不需要 VDom ，即返祖。少了 VDom，运行时性能自然飙升。

除此之外，就是追求极致的开发体验，如 Svelte.js 的响应式极端魔法，受其影响，Vue v3 也想为 ref 设计一个语法糖，但目前夭折了，因为这会导致框架的进一步分裂。而 Solid.js 就是「响应式」版的 React，推崇无依赖性（ Hook deps ），降低心智负担。

## 追求性能

深入了解之后发现，前一小结的内容大部分都跟编译有关，无论是 VDom 转化为 HTML ，还是 Angular 的装饰器、自动依赖注入，亦或是 Vue 和 Svelte 的模板优化，都离不开编译。

这也是促使前端冲向编译领域热潮的一个原因，另外一个原因就是构建工具的速度已经不能满足当前的时代，他俩与 Rust 共同创造了繁荣的「前端编译社区」。

首当其冲的是 Vite，基于 ESM 的文件级编译，但缺点在于无法处理大量的非 ESM IO 操作，所以在 Webpack v5 支持了编译缓存的情况下，应对大量编译场景，它们的性能优势是不分上下的，有可能 Webpack 更优。

新一代构建工具，TurboPack （涡轮增压）函数级编译。

ESBuild、SWC、PostCSS-rs、ESLint、Prettier 有关 IO 及其编译的操作

## 项目管理

包管理器、工作空间、发布系统

## 跨端渲染

### CSR

传统单页面应用（SPA）的渲染方式采用的是客户端渲染（CSR）。

即请求服务器，下发的是一个只附带 main.js 脚本的空页面结构：

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>App</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="./assets/main.xxxx.js"></script>
  </body>
</html>
```

这会经历以下过程：

1. 当浏览器解析到 main 脚本时，执行下载流程
2. 下载完毕，执行 main 脚本
3. 根据脚本内容动态创建 HTML 结构，如：`document.body.innerHTML = 'xxxx'`

缺陷：

1. 若 main 脚本体积过大，下载时间变长，影响后续渲染过程，即首屏渲染速度缓慢
2. 影响 SEO 优化，当然目前谷歌能够支持在 JS 文件中扫描关键字
3. 路由跳转同理，从头开始下载解析，再渲染

### SSR

既然 CSR 是在客户端执行脚本渲染页面，那将这个过程放置在服务端进行，即：

1. 浏览器请求页面，服务器渲染静态页面结构，同时下发一个 hydration 脚本
2. 执行 hydration 脚本，为静态页面结构补充事件绑定，保证页面最终可交互
3. 路由切换交由客户端控制，同 CSR

优势：

1. 首屏速度极快
2. 利于 SEO 优化

缺陷：

1. hydration 过程及其复杂，需找出要补充事件的元素，以及事件的类型，恢复状态，而这一切在服务端渲染的时候就已经知晓，到达客户端时需要再做一遍同样的事情，整个过程可能会耗时，从而影响可交互时间
2. 依赖于服务器实现

### SSR - Resumable

鉴于传统 SSR 不必要的 hydration 过程，提出可恢复性（Resumability）概念。

将元素的事件、状态映射信息保存在 DOM 元素的属性上，跟随页面下发的还有这些状态事件的 JSON 映射。在触发事件时，通过框架运行时去动态寻找（下载）对应的处理程序，从而达到惰性创建事件、绑定事件的目的。

优势：

1. 基于 SSR 的优势，减少了可交互时间

## 参考

- [新时代的 SSR 框架破局者：qwik](https://zhuanlan.zhihu.com/p/597473358)
- [2022 大前端总结和 2023 就业分析](https://zhuanlan.zhihu.com/p/603410758)
