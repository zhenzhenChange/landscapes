# FE 发展动向与趋势

## 框架发展

### 开发模式转变

主流框架发展重要节点：

- 2020-09-18 Vue v3.0.0 发布
- 2019-02-06 React v16.8.0 发布
- 2016-09-15 Angular v2.0.0 发布

随着 Vue v3.x 的发布，意味着前端框架已趋于成熟，都拥有了「状态 + 逻辑」的复用能力，「状态管理」即将落入历史长河。

「状态管理」的思维模式是合理的，但就已具象化的各个状态管理库而言，太过于追求「政治正确（思维固化）」，随着软件应用的越亦复杂，流行并不意味着永远正确，软件工程没有银弹，必然需要变革。

很少有人能够掌控全局的各个数据流（需要大量的时间去梳理，无疑增加了用人成本），由于数据与逻辑分散各地，导致样板代码暴增，逻辑书写混乱。

传统业务开发步骤：

1. 根据视图所需确定数据实体
2. 于 GlobalStore 创建实体对象
3. 在业务中从 GlobalStore 索取数据实体
4. 根据数据实体开发业务逻辑
5. 将数据与逻辑（事件）绑定到视图中

在 DDD 中，上述第 2 个步骤所创建的大型 Store 对象称之为「贫血模型」。

贫血模型的优势有许多，简单罗列几点：

1. 层次划分清晰
2. 各层单向依赖
3. 数据同步易控

但是！在传统的前端开发中，随着业务的爆发式增长，频繁的对贫血模型进行更新变动，无疑是增加的维护成本。将贫血模型作为 Model 层，转而将业务逻辑书写在组件当中，反向依赖了数据实体。

并且由上述步骤可知，若无数据，寸步难行，进一步推论，业务的开发居然要依赖视图是如何的表现？

视图是实现细节，业务逻辑应当是抽象的，与视图无关的，视图应当作为消费者消费数据，而不是作为造物者创造抽象数据（GlobalStore 是生产者生产实体数据）。

那么缺点显而易见：

1. 对于组件而言，数据源头难以追溯（人肉搜索、单点跳个七八步）；
2. 对于 Store 而言，业务逻辑难以发现（这也就意味着，同样的一块业务逻辑有可能出现在多个组件中，无复用性可言）；
3. 不具备封装性、可移植性（数据实体是暴露的，任何人员可以修改之；状态与逻辑的分离，导致移植时需要重新组装或重写）。

这将极大的阻碍了开发效率，至于所谓的调试工具，安慰而已。

所以，「状态管理」对于小型项目无必要，大型项目则是鸡肋。

而「状态逻辑管理」则是典型的「充血模型」，将数据与逻辑聚合封装，解决上述所有缺点，即统称为服务（Service）。

随之而来的就是需要解决各个组件中需要同步状态的问题：运用「依赖注入」，实施单例模式（根据实际情况运用多例模式），与全局或某个组件根提供服务实例，下层组件共享同一个实例，以此达到数据同步的目的。

> 实际上很多状态管理库就是使用依赖注入来实现数据同步的，比如对于 Vue v3 来说，新开发的 Pinia 已经不是单纯的状态管理库了，它将支持状态与逻辑的封装，即 setup 模式，于全局进行实例注册（provide），与组件处注入（inject）。

再者就是由于架构模式的不同，他们的发展方向也会有些差异，Angular 是基于事件驱动，Vue 基于响应式的数据驱动，而 React 则是基于不可变性的状态驱动。

那么这些框架剩下的工作就是千锤百炼，精益求精了，如：Vue v3.2 的 setup-sugar 以及 React v18 的并发延迟 Hooks 等。

### 返祖现象飙升

现代框架「返祖」：

- Solid.js
- Svelte.js
- Vue v3.x Vapor - Non-VDom Compilation Strategy

去 VDom 化，追求极致的「声明式」开发体验，编译成纯原生的「命令式」源码。

因为 VDom 最强大的是抽象能力，使其拥有强大的跨平台能力。除此之外，框架本身一般还会对 VDom 进行增强，创造属于自己的 DSL （Template vs JSX），如 Vue 的 Block Tree 以及 React 的 Fiber Tree，这也就意味着应用在执行是需要框架的运行时功能。

> Atwood 定律：Any application that can be written in JavaScript, will eventually be written in JavaScript.

当我们不需要跨平台的时候（或者跨平台本身就是个伪需求），那也就意味着我们不需要 VDom ，即返祖。少了 VDom，运行时性能自然飙升。

除此之外，就是追求极致的开发体验，如 Svelte.js 的响应式极端魔法，受其影响，Vue v3 也想为 ref 设计一个语法糖，但目前夭折了，因为这会导致框架的进一步分裂。而 Solid.js 就是「响应式」版的 React，推崇无依赖性（ Hook deps ），降低心智负担。

## 编译基建

深入了解之后发现，前一小结的内容大部分都跟编译有关，无论是 VDom 转化为 HTML ，还是 Angular 的装饰器、自动依赖注入，亦或是 Vue 和 Svelte 的模板优化，都离不开编译。

这也是促使前端冲向编译领域热潮的一个原因，另外一个原因就是构建工具的速度已经不能满足当前的时代，他俩与 Rust 共同创造了繁荣的「前端编译社区」。

首当其冲的是 Vite，基于 ESM 的文件级编译，但缺点在于无法处理大量的非 ESM 的 IO 操作，比如 CSS 编译解析。

所以在 Webpack v5 支持了编译缓存的情况下，应对这种非 ESM 的编译场景，它们的性能优势其实是不分上下的，有可能 Webpack 更优。

新一代构建工具，TurboPack （涡轮增压）函数级编译，在无副作用的情况下，既然对于相同的输入，必然产生相同的输出，那不如直接对函数的执行结果进行缓存，这又进一步的提升了开发时的编译速度。

除此之外，无论是 Babel 的替代品 ESBuild、SWC，还是 PostCSS 的替代品 PostCSS-rs 等有关编译的操作，都是在解决项目构建时的性能问题，也带火了 Rust 社区，关于 Rust 了解甚少，略过。

不过可以展望的是，Rust 在未来有可能成为新时代的基建语言，Deno 也有可能焕发第二春。

## 项目管理

### 包管理

### 工作空间

### 发布系统

包管理器、工作空间、发布系统

## 跨端渲染

### CSR

传统单页面应用（SPA）的渲染方式采用的是客户端渲染（CSR）。

即请求服务器，下发的是一个只附带 main.js 脚本的空页面结构：

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>App</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="./assets/main.xxxx.js"></script>
  </body>
</html>
```

这会经历以下过程：

1. 当浏览器解析到 main 脚本时，执行下载流程
2. 下载完毕，执行 main 脚本
3. 根据脚本内容动态创建 HTML 结构，如：`document.body.innerHTML = 'xxxx'`

缺陷：

1. 若 main 脚本体积过大，下载时间变长，影响后续渲染过程，即首屏渲染速度缓慢
2. 影响 SEO 优化，当然目前谷歌能够支持在 JS 文件中扫描关键字
3. 路由跳转同理，从头开始下载解析，再渲染

### SSR

既然 CSR 是在客户端执行脚本渲染页面，那将这个过程放置在服务端进行，即：

1. 浏览器请求页面，服务器渲染静态页面结构，同时下发一个 hydration 脚本
2. 执行 hydration 脚本，为静态页面结构补充事件绑定，保证页面最终可交互
3. 路由切换交由客户端控制，同 CSR

优势：

1. 首屏速度极快
2. 利于 SEO 优化

缺陷：

1. hydration 过程及其复杂，需找出要补充事件的元素，以及事件的类型，恢复状态，而这一切在服务端渲染的时候就已经知晓，到达客户端时需要再做一遍同样的事情，整个过程可能会耗时，从而影响可交互时间
2. 依赖于服务器实现

### SSR - RSC + Selection Hydration

### SSR - Islands/Partial Hydration vs Selection Hydration

### SSR - Resumable

鉴于传统 SSR 不必要的 hydration 过程，提出可恢复性（Resumability）概念。

将元素的事件、状态映射信息保存在 DOM 元素的属性上，跟随页面下发的还有这些状态事件的 JSON 映射。在触发事件时，通过框架运行时去动态寻找（下载）对应的处理程序，从而达到惰性创建事件、绑定事件的目的。

优势：

1. 基于 SSR 的优势，减少了可交互时间

## 参考

- [新时代的 SSR 框架破局者：qwik](https://zhuanlan.zhihu.com/p/597473358)
- [2022 大前端总结和 2023 就业分析](https://zhuanlan.zhihu.com/p/603410758)
