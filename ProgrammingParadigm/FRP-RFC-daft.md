新值与旧值

所以，响应式的核心概念只有三个：

1. 拥有一个响应单元
2. 拥有自动响应能力

即 ref + watch，此外还有一个响应衍生的能力，本质上只是 ref + watch 的语法糖。

### 行为、事件、逻辑

很多东西有不同的叫法，只是为了更能体现自己的特性。

### 同步、调度、管理

### 业务交互与视图交互

业务交互 = 业务状态 + 业务逻辑

视图交互 = 视图状态 + 视图逻辑

### 贫血模型与充血模型

### MVVM -> MVI

## 状态管理

什么是管理？一直以来都没有好好思考过这个词的含义，潜意识的只是按照字面意思，认为管理就是维护、约束、集中。

其实不然，管理是指一定组织中的管理者，通过实施计划、组织、领导、协调、控制等职能来协调他人的活动，使别人同自己一起实现既定目标的活动过程。是人类各种组织活动中最普通和最重要的一种活动。

摘取关键词并总结：通过某种手段，控制外部的行为，使其与己协同工作。

在计算机的世界中，这个「某种手段」，就是「调度」。

## 状态同步

## 缘分

createService + fellow student

思考到什么程度？

- 洗澡的时候有时会想一些问题，以致于我回过神之后，却忘记了刚刚到底洗头了没有。
- 坐地铁的时候思考问题，有时候会坐过站，不过现在已经形成了肌肉记忆。
- 过马路的时候也会思考，但这是不好的习惯。

React 要求函数是纯的，但是真实世界中必然会有副作用，于是纯函数与副作用之间需要一种手段进行调度，即 useEffect，setState 就是一个 dispatcher。我们所有的副作用都必须在 useEffect 中处理。computed 是 watch 的简写：

由于 React 每次都会 re-run，当状态未变时直接回 bailout，所以如若某个组件中有复杂的计算，有可能会阻塞渲染，此时 useMemo 就派上用场。

```ts
const count = ref(0)

const computedDouble = computed(() => count.value * 2)

const watchDouble = ref(count.value)
watch(count, (v) => (watchDouble.value = v))
```

- 纯函数
- 副作用
- 不变性

React 和 Vue 新版都在解决 Service 上的问题。

## 什么是 model

贫血模型 - 函数式

充血模型 - 面向对象

angular 才是真正意义上的 MVVM 框架，而 vue 和 react 只是 VM 库

Rxjs 是将人机交互建模为相互依赖的可观察对象。

## 组合和聚合

> <https://github.com/vuejs/docs-next-zh-cn/issues/53>

在函数式编程中，函数是第一类（first class）公民，函数式编程由“行为”和“事件”组成。事件是基于时间的离散序列，而行为是不可变的，是随着时间连续变化的数据。函数式编程与响应式编程相比，它更偏重于底层编码的实现细节。

## 终末

本文横跨了多个技术领域或场景，包含但不仅限于：

- 分层架构（Model View Intent，MVI | Model View ViewModel，MVVM）
- 前端框架（Vue | React | Solid | Angular）
- 数据驱动（Data Driven）
- 事件驱动（Event Driven）
- 状态管理（State Management）
- 状态逻辑管理（State Logic Management）
- 领域驱动设计（Domain-Driven Design，DDD）
- 声明式编程
- 命令式编程
- 响应式编程（Reactive Programming，RP）
- 函数式编程（Functional Programming，FP）
- 函数式响应式编程（Functional Reactive Programming，FRP）

## 物以类聚人以群分

没有问题，但是分类需要有边界。

举例：

我有一个主机和显示器，配了一个无线鼠标和一个无线键盘，共同组合成一台个人电脑。其中，主机可以任意放置在任意地方（假设线头够长），同理，显示器可以放置任意地方，假设你是千里眼。再者，无线键鼠也可以任意放置，只要在无线接收器的范围内，以及你的手够长。注意，这里的范围被无限扩大了，本身就带来了很多问题，因为不合理。

所以，首先我们得划定一个界限，将所有的东西先放置在一个房间内，即项目中。

当我的电脑再增加一个，依旧是这样的分法，没问题。

继续加，继续分，当加到 10 个的时候，依旧是键鼠放置一起，显示器放置一起，主机放在一起。

这时候问题就会出现了，你怎么知道哪套键鼠是属于哪套主机的呢？无线接收器在配对的时候你知道，配对完之后的信号发射，是肉眼不可见的。

所以，你在操作的时候，必须要时刻观察是哪台电脑动了，而且，还需要排除其它电脑带来的影响。

要解决这个问题，只有两个，一是熟能生巧，二是增加命名空间。

但是这只能缓解问题而不能解决问题，熟能生巧不利于新手介入，命名空间仍有尽头（指的是人脑所能承受的范围，一百个命名空间你要怎么起名，你要怎么记？）

第二个问题，就是可维护性、可移植性，你需要在众多分类中找出属于这台电脑的所有组成部分，才可将其移除（报废了），或是移入另一个房间（移植）。

这很考验维护人员的耐心，否则可能会遗留无用的产物，对房间增加负担，日益臃肿。

处于便利性（可移植性）而言，于是便研发出了笔记本电脑（不同的是，鼠标变为的触控板，当然意思差不多得了）
